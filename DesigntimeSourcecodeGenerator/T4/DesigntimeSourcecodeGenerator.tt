<#@ template language="C#" debug="true" hostspecific="true" #>
<#@ output extension="cs"#>
<#@ import namespace="System"#>
<#@ include file="EnvDTEUtilily.t4include" #>
<#
	var filecreate = new System.Collections.Generic.Dictionary<string, bool>();

	//ソリューションのプロジェクトを全て列挙
	var projects = FindAllProjects();
	foreach (var project in projects)
	{
		ProjectTour(project, filecreate);
	}
#>
<#+
	/// <summary>
	/// ソリューションアイテムからプロジェクトを探してテンプレート処理を行う
	/// </summary>
	private void ProjectTour(Project project, System.Collections.Generic.Dictionary<string, bool> filecreate)
	{
		var name = project.Name;
		
		if(name == ".nuget")
		{
			// nugetフォルダをスキップ
			return;
		}
		if(project.ProjectItems == null)
		{
			// アンロードプロジェクトをスキップ
			return;
		}
		if (project.Kind == ProjectKinds.vsProjectKindSolutionFolder)
		{
			// ソリューションフォルダの場合は、サブプロジェクトを処理する
			foreach (var projectItem in GetProjectItems(project)) 
			{
				var itemName = projectItem.Name;
				var subProject = projectItem.SubProject;

				if(subProject != null)
				{
					ProjectTour(subProject, filecreate);
				}
			}
		}
		else
		{
			foreach (var projectItem in GetProjectItems(project)) 
			{
				var itemName = projectItem.Name;

				// プロジェクト中、属性TemplateGenerateAnnotationで修飾されているクラスのみ抽出する
				var classes = GetCodeElements(projectItem)
					.Where(el => el.Kind == vsCMElement.vsCMElementClass).Cast<CodeClass>()
					.Where(cl => Attributes(cl).Any(at => at.Name.StartsWith("TemplateGenerateAnnotation")));

				foreach (var clazz in classes)
				{
					//ファイルに出力                   
					int lastDot = projectItem.FileNames[0].LastIndexOf(@".");
					string filePath = projectItem.FileNames[0].Substring(0, lastDot);
					string generatedFileName = filePath + ".generated.cs";
					bool first = false;

					if (File.Exists(projectItem.FileNames[0]) && File.Exists(generatedFileName))
					{
						var originUpdate = System.IO.File.GetLastWriteTime(projectItem.FileNames[0]);
						var generatedUpdate = System.IO.File.GetLastWriteTime(generatedFileName);

						if(originUpdate <= generatedUpdate && !filecreate.ContainsKey(generatedFileName))
						{
							continue;
						}
					}
					if(!filecreate.ContainsKey(generatedFileName))
					{
						// 初回ファイル初期化
						File.Delete(generatedFileName);
						filecreate.Add(generatedFileName, true);
						first = true;
					}
					GenerateClass(clazz, first);
					SaveOutput(generatedFileName, project);
				}
			}
		}
	}

	/// <summary>
	/// PropertyDecl属性を元にクラスを生成します
	/// </summary>
	private void GenerateClass(CodeClass clazz, bool first)
	{
		//テンプレートのパスを取得
		string T4TemplatePath = Path.GetDirectoryName(Host.TemplateFile);
		string fileName = Path.GetFileName(Host.TemplateFile);
		//対象クラスと同じ名前空間として定義する
		string classNamespace = clazz.Namespace.Name;
		string className =  clazz.Name;

		var attrDic = new Dictionary<string, List<string>>();

		//クラスの属性AttributeDefinitionを抽出
		var classAttributes = Attributes(clazz).Where(at => at.Name.StartsWith("AttributeDefinition"));

		foreach (var attribute in classAttributes)
		{
			var paramDic = new Dictionary<string, string>();
			var attributeArgs 
				= CodeAttributeArgumentInCodeAttribute(attribute).ToArray<EnvDTE80.CodeAttributeArgument>();

			for (var i = 0; i < attributeArgs.Length; i++)
			{
				var arg = attributeArgs[i];
				string argValue = arg.Value.Substring(1, arg.Value.Length - 2).Replace("\\", "").Trim();

				paramDic.Add(arg.Name, argValue);
			}
			string propertyName;
			paramDic.TryGetValue("Name", out propertyName);

			string propertyAttributed;
			paramDic.TryGetValue("Attributed", out propertyAttributed);

			string key = clazz.FullName + ":" + propertyName;

			if(!attrDic.ContainsKey(key))
			{
				var list = new List<string>();
				list.Add(propertyAttributed);
				attrDic.Add(key, list);
			}
			else
			{
				var list = attrDic[key];
				list.Add(propertyAttributed);
			}
		}

		// 親クラスとインターフェースを取得
		// string baseInterface = GetBaseInterface(clazz);
		
		if(first)
		{
			// ファイルの書き始めだけに、自動生成コメントタグを付加する
#>
// <auto-generated />
<#+
		}
#>
namespace <#= classNamespace #>
{
	using System;
	using System.Windows;
	using System.Windows.Controls;
	using System.ComponentModel;

	/// <summary>
	/// このクラスは<#=className#>クラスの定義によって、自動生成されました。
	/// このファイルをエディタで直接編集しないでください。
	/// </summary>
	public partial class <#= className #>
	{
<#+
		// TemplateGenerateAnnotation属性を抽出
		var attributes = Attributes(clazz).Where(att => att.Name=="TemplateGenerateAnnotation");
		foreach(CodeAttribute attribute in attributes)
		{
			var argDic = new Dictionary<string, string>();
			var attributeArgs 
				= CodeAttributeArgumentInCodeAttribute(attribute).ToArray<EnvDTE80.CodeAttributeArgument>();
			
			for (var i = 0; i < attributeArgs.Length; i++)
			{
				var arg = attributeArgs[i];
				var argValue = arg.Value.Replace("\"", "").Replace("typeof", "").Replace("(", "").Replace(")", "").Trim(); 
				
				argValue = argValue.Replace("&quot;", "\"").Replace("&#40;", "(").Replace("&#41;", ")");
				argDic.Add(arg.Name, argValue);                      
			}
			
			//文字列になっている属性値をプロパティ名、型、デフォルト値、コンバータ、変更通知に振り分ける
			string propertyName;
			argDic.TryGetValue("Name", out propertyName);

			string propertyType;
			argDic.TryGetValue("Type", out propertyType);

			string propertyComment;
			argDic.TryGetValue("Comment", out propertyComment);
			if(string.IsNullOrEmpty(propertyComment))
			{
				propertyComment = "";
			}

			string propertyKind;
			argDic.TryGetValue("Kind", out propertyKind);
			if(string.IsNullOrEmpty(propertyKind))
			{
				propertyKind = "Basic";
			}

			string globalVariableEnum;
			argDic.TryGetValue("GlobalVariableEnum", out globalVariableEnum);

			string summary = null;
			//string metadata = null;

			string defaultValue = string.Empty;
			argDic.TryGetValue("DefaultValue", out defaultValue);

			string typeConverter;
			argDic.TryGetValue("converterType", out typeConverter);

			string notifyPropertyChangedStr;
			bool notifyPropertyChanged = true;
			if ( argDic.TryGetValue("RaisePropertyChanged", out notifyPropertyChangedStr))
			{
				bool.TryParse(notifyPropertyChangedStr, out notifyPropertyChanged);
			}
			else
			{
				notifyPropertyChanged = false;
			}

			string setterPrivateStr;
			bool setterPrivate = true;
			if ( argDic.TryGetValue("SetterPrivate", out setterPrivateStr))
			{
				bool.TryParse(setterPrivateStr, out setterPrivate);
			}
			else
			{
				setterPrivate = false;
			}

			string setNotificatorStr;
			bool setNotificator = true;
			if ( argDic.TryGetValue("SetNotificator", out setNotificatorStr))
			{
				bool.TryParse(setNotificatorStr, out setNotificator);
			}
			else
			{
				setNotificator = false;
			}

			string propertyChangedCallbackStr;
			bool propertyChangedCallback = true;
			if ( argDic.TryGetValue("PropertyChangedCallback", out propertyChangedCallbackStr))
			{
				bool.TryParse(propertyChangedCallbackStr, out propertyChangedCallback);
			}
			else
			{
				propertyChangedCallback = false;
			}

			string canGenetateStr;
			bool canGenetate = true;
			if ( argDic.TryGetValue("CanGenetate", out canGenetateStr))
			{
				bool.TryParse(canGenetateStr, out canGenetate);
			}
			else
			{
				canGenetate = false;
			}

			string routingStrategy;
			if(!argDic.TryGetValue("RoutingStrategy", out routingStrategy))
			{
				routingStrategy = "RoutingStrategy.Tunnel";
			}

			string commandParameter;
			if(!argDic.TryGetValue("CommandParameter", out commandParameter))
			{
				commandParameter = string.Empty;
			}

#>
#region <#= propertyComment #>
		/// <summary>
		/// <#= propertyComment #>
		/// </summary>
<#+        
			string key = clazz.FullName + ":" + propertyName;
			List<string> list = new List<string>();

			if(attrDic.ContainsKey(key))
			{
				list = attrDic[key];
			}

			if(propertyKind == "Basic")
			{
				if(!notifyPropertyChanged)
				{
					// 単純プロパティの生成
					GenerateAttributeField(list);
					GenerateBasicAccessor(typeConverter, propertyType, propertyName, summary, setterPrivate);
				}
				else
				{
					// PropertyChangedイベントの生成
					GenerateField(typeConverter, propertyType, propertyName, defaultValue);
					GenerateAttributeField(list);
					GenerateCLRAccessor(typeConverter, propertyType, propertyName, summary, notifyPropertyChanged, setterPrivate, setNotificator);
				}
			}
			else if(propertyKind == "DependencyProperty")
			{
				// 依存プロパティの生成
				GenerateDependencyProperty(typeConverter, propertyType, propertyName, summary, className, defaultValue);
			}
			else if(propertyKind == "UIPropertyMetadata")
			{
				// 依存関係プロパティの生成
				GenerateUIPropertyMetadata(typeConverter, propertyType, propertyName, summary, className, defaultValue, setterPrivate, propertyChangedCallback);
			}
			else if(propertyKind == "PropertyChangedCallback")
			{
				// 依存関係プロパティの生成
				GeneratePropertyChangedCallback(typeConverter, propertyType, propertyName, summary, className, defaultValue);
			}
			else if(propertyKind == "GlobalVariableManager")
			{
				// GlobalVariableManagerプロパティの生成
				GenerateAttributeField(list);
				GenerateGlobalVariableManager(typeConverter, propertyType, propertyName, summary, globalVariableEnum);
			}
			else if(propertyKind == "Command" && commandParameter == string.Empty)
				// コマンドの生成
			{
				GenerateCommand(propertyName, canGenetate);
			}
			else if(propertyKind == "Command" && commandParameter != string.Empty)
			{
				GenerateListenerCommand(propertyName, canGenetate, commandParameter);
			}
			else if(propertyKind == "Event")
			{
				// イベントの生成
				GenerateEvent(propertyName);
			}
			else if(propertyKind == "RoutedEvent")
			{
				// イベントの生成
				GenerateRoutedEvent(propertyName, className, routingStrategy);
			}
			else if(propertyKind == "Logger")
			{
				// ロガーの生成
				GenerateLogger();
			}
			else if(propertyKind == "Singleton")
			{
				// シングルトンの生成
				GenerateSingleton(className);
			}
#>
#endregion
<#+
		} // end foreach dps
#>
	}
}
<#+
	} // end generate class
#>

<#+
/// <summary>
/// フィールドを生成します
/// </summary>
private void GenerateField(string typeConverter, string propertyType
	, string propertyName, string defaultValue)
{
	var fieldname = "_" + Decapitalize(propertyName);
#>
		private <#= propertyType #> <#= fieldname #><#= (!string.IsNullOrEmpty(defaultValue)) ? "= " + defaultValue : "" #>;
<#+
}
/// <summary>
/// アトリビュートを生成します
/// </summary>
private void GenerateAttributeField(List<string> list)
{
	if(list.Count > 0)
	{
		foreach(var attstr in list)
		{
#>
		[<#= attstr #>]
<#+
		}
	}
}
/// <summary>
/// コマンドを生成します
/// </summary>
private void GenerateCommand(string name, bool canGenetate)
{
	var sname = Decapitalize(name);
#>
		private Livet.Commands.ViewModelCommand _<#= sname #>Command;

		public Livet.Commands.ViewModelCommand <#= name #>Command
		{
			get
			{
				if (this._<#= sname #>Command == null)
				{
					this._<#= sname #>Command = new Livet.Commands.ViewModelCommand(this.<#= name #><#+ if(canGenetate){#>, this.Can<#= name #><#+}#>);
				}
				return this._<#= sname #>Command;
			}
		}
<#+
	if(canGenetate)
	{
#>
		//private bool Can<#= name #>() { return true; }
<#+
	}
}
private void GenerateListenerCommand(string name, bool canGenetate, string commandParameter)
{
	var sname = Decapitalize(name);
#>
		private Livet.Commands.ListenerCommand<<#= commandParameter #>> _<#= sname #>Command;

		public Livet.Commands.ListenerCommand<<#= commandParameter #>> <#= name #>Command
		{
			get
			{
				if (this._<#= sname #>Command == null)
				{
					this._<#= sname #>Command = new Livet.Commands.ListenerCommand<<#= commandParameter #>>(this.<#= name #><#+ if(canGenetate){#>, this.Can<#= name #><#+}#>);
				}
				return this._<#= sname #>Command;
			}
		}
		//private void <#= name #>(<#= commandParameter #> message) {}
<#+
	if(canGenetate)
	{
#>
		//private bool Can<#= name #>() { return true; }
<#+
	}
}
private void GenerateEvent(string name)
{
#>
		public delegate void <#= name #>EventHandler(object sender, <#= name #>EventArgs e);
		public event <#= name #>EventHandler <#= name #>;

		protected virtual void On<#= name #>(<#= name #>EventArgs e)
		{
			if (this.<#= name #> != null)
			{
				this.<#= name #>(this, e);
			}
		}
		// public class <#= name #>EventArgs : EventArgs {}
<#+
}
private void GenerateRoutedEvent(string name, string className, string routingStrategy)
{
#>
		public static RoutedEvent <#= name #>Event = EventManager.RegisterRoutedEvent("<#= name #>", <#= routingStrategy #>, typeof(<#= name #>EventHandler), typeof(<#= className #>));
		public event <#= name #>EventHandler <#= name #>
		{
			add { this.AddHandler(<#= name #>Event, value); }
			remove { this.RemoveHandler(<#= name #>Event, value); }
		}
		public delegate void <#= name #>EventHandler(object sender, <#= name #>EventArgs e);
		//public class <#= name #>EventArgs : RoutedEventArgs
		//{
		//	public <#= name #>EventArgs(RoutedEvent routedEvent) : base(routedEvent) {}
		//}
<#+
}
private void GenerateLogger()
{
#>
		[System.Diagnostics.CodeAnalysis.SuppressMessage("StyleCop.CSharp.NamingRules", "SA1311:StaticReadonlyFieldsMustBeginWithUpperCaseLetter", Justification = "Reviewed.")]
		private static readonly log4net.ILog logger = log4net.LogManager.GetLogger(System.Reflection.MethodBase.GetCurrentMethod().DeclaringType);
<#+
}
private void GenerateSingleton(string className)
{
#>
		public static readonly <#= className #> Instance = new <#= className #>();

		static <#= className #>()
		{
			StaticConstructor();
		}
		private <#= className #>()
		{
			this.InstanceConstructor();
		}
		//static void StaticConstructor() {}
		//private void InstanceConstructor() {}
<#+
}
/// <summary>
/// Basicプロパティの生成します
/// </summary>
private void GenerateBasicAccessor(string typeConverter, string propertyType, string propertyName, string summary, bool privateSetter)
{
	if (!string.IsNullOrEmpty(summary))
	{
		GeneratePropertyComment(summary);
	}
#>
		public <#= propertyType #> <#= propertyName #> { get; <#= privateSetter ? "private" : ""#> set; }
<#+
}
/// <summary>
/// CLRプロパティのアクセサを生成します
/// </summary>
private void GenerateCLRAccessor(string typeConverter, string propertyType
	, string propertyName, string summary, bool notifyPropertyChanged, bool privateSetter, bool setNotificator)
{
	var fieldname = "_" + Decapitalize(propertyName);
	string typeConverterDefinition = typeConverter!= null 
						? "[TypeConverter(typeof(" + typeConverter + "))]" 
						: "";
	if (!string.IsNullOrEmpty(summary))
	{
		GeneratePropertyComment(summary);
	}

	if (!string.IsNullOrEmpty(typeConverterDefinition))
		GenerateTypeConverterDefinition(typeConverterDefinition);
#>
		public <#= propertyType #> <#= propertyName #>
		{
			get { return this.<#= fieldname #>; }
			<#= privateSetter ? "private " : ""#>set 
			{ 
				if ( this.<#= fieldname #> == value ) {
					return;
				}
				this.<#= fieldname #> = value; 
				<#= setNotificator ? "this." + propertyName + "Notification();" : "" #>
<#+
	if ( notifyPropertyChanged ) 
		GenerateNotifyChanged(propertyName);       
#>
			}
		}
<#+
	if (setNotificator)
	{
#>
		public <#= propertyType #> Silent<#= propertyName #>
		{
			<#= privateSetter ? "private " : ""#>set 
			{ 
				if ( this.<#= fieldname #> == value ) {
					return;
				}
				this.<#= fieldname #> = value; 
				this.RaisePropertyChanged(() => this.<#= propertyName #>);
			}
		}
<#+
	}
}
/// <summary>
/// DependencyProperty生成します
/// </summary>
private void GenerateDependencyProperty(string typeConverter, string propertyType, string propertyName, string summary, string className, string defaultValue)
{
	if (!string.IsNullOrEmpty(summary))
	{
		GeneratePropertyComment(summary);
	}
#>
		public static readonly DependencyProperty <#= propertyName #>Property = DependencyProperty.Register("<#= propertyName #>", typeof(<#= propertyType #>), typeof(<#= className #>));
		public <#= propertyType #> <#= propertyName #>
		{
			get { return (<#= propertyType #>)this.GetValue(<#= propertyName #>Property); }
			set { this.SetValue(<#= propertyName #>Property, value); }
		}
<#+
}
/// <summary>
/// UIPropertyMetadata生成します
/// </summary>
private void GenerateUIPropertyMetadata(string typeConverter, string propertyType, string propertyName, string summary, string className, string defaultValue, bool setterPrivate, bool propertyChangedCallback)
{
	if (!string.IsNullOrEmpty(summary))
	{
		GeneratePropertyComment(summary);
	}
#>
		public static readonly DependencyProperty <#= propertyName #>Property = DependencyProperty.Register("<#= propertyName #>", typeof(<#= propertyType #>), typeof(<#= className #>), new UIPropertyMetadata(<#= defaultValue #>, On<#= propertyName #>));
		public <#= propertyType #> <#= propertyName #>
		{
			get { return (<#= propertyType #>)this.GetValue(<#= propertyName #>Property); }
			<#= setterPrivate ? "private" : ""#> set { this.SetValue(<#= propertyName #>Property, value); }
		}
<#+
	if(propertyChangedCallback)
	{
#>
		private static void On<#= propertyName #>(DependencyObject depObj, DependencyPropertyChangedEventArgs e)
		{
			var o = (<#= className #>)depObj;

			if(o != null)
			{
				o.Set<#= propertyName #>((<#= propertyType #>)e.NewValue);
			}
		}
		//private void Set<#= propertyName #>(<#= propertyType #> value) {}
<#+
	}
	else
	{
#>
		//private static void On<#= propertyName #>(DependencyObject depObj, DependencyPropertyChangedEventArgs e)
		//{
		//}
<#+
	}
}
/// <summary>
/// GeneratePropertyChangedCallback生成します
/// </summary>
private void GeneratePropertyChangedCallback(string typeConverter, string propertyType, string propertyName, string summary, string className, string defaultValue)
{
	if (!string.IsNullOrEmpty(summary))
	{
		GeneratePropertyComment(summary);
	}
#>
		public static readonly DependencyProperty <#= propertyName #>Property = DependencyProperty.Register("<#= propertyName #>", typeof(<#= propertyType #>), typeof(<#= className #>), new FrameworkPropertyMetadata((<#= propertyType #>)<#= defaultValue #>, new PropertyChangedCallback(On<#= propertyName #>Changed)));
		public <#= propertyType #> <#= propertyName #>
		{
			get { return (<#= propertyType #>)this.GetValue(<#= propertyName #>Property); }
			set { this.SetValue(<#= propertyName #>Property, value); }
		}
		//private static void On<#= propertyName #>Changed(DependencyObject depObj, DependencyPropertyChangedEventArgs e)
		//{
		//	<#= className #> ctrl = (<#= className #>)depObj;
		//}
<#+
}
/// <summary>
/// GlobalVariableManagerプロパティの生成します
/// </summary>
private void GenerateGlobalVariableManager(string typeConverter, string propertyType, string propertyName, string summary, string globalVariableEnum)
{
	if (!string.IsNullOrEmpty(summary))
	{
		GeneratePropertyComment(summary);
	}
#>
		public <#= propertyType #> <#= propertyName #>
		{
			get
			{
				return _2ndFactory.Common.Wpf.Manager.GlobalVariableManager.Instance.GetValue<<#= propertyType #>>(<#= globalVariableEnum #>);
			}

			set
			{
				if (_2ndFactory.Common.Wpf.Manager.GlobalVariableManager.Instance.GetValue<<#= propertyType #>>(<#= globalVariableEnum #>) == value)
				{
					return;
				}
				_2ndFactory.Common.Wpf.Manager.GlobalVariableManager.Instance.SetValue(<#= globalVariableEnum #>, value);
				this.RaisePropertyChanged();
			}
		}

<#+
}





/// <summary>
/// コメントブロックを生成します
/// </summary>
private void GeneratePropertyComment(string summary)
{
#>
		/// <summary>
		/// <#= summary #>.
		/// </summary>
<#+
}
/// <summary>
/// 型コンバータ定義をを生成します
/// </summary>
private void GenerateTypeConverterDefinition(string typeConverterDefinition)
{
#>
		<#= typeConverterDefinition #>
<#+
}
/// <summary>
/// 型コンバータ定義をを生成します
/// </summary>
private void GenerateNotifyChanged(string propertyName)
{
#>
				this.RaisePropertyChanged(() => this.<#= propertyName #>);
<#+
}
/// <summary>
/// 先頭を小文字に変換した文字列を取得します(デキャピタライズ)
/// </summary>
/// <param name="name">対象の文字をセット</param>
/// <returns>先頭が小文字に変換された文字列が戻ります</returns>
private static string Decapitalize(string name)
{
	if (string.IsNullOrEmpty(name)) {
		return name;
	}
	char[] chars = name.ToCharArray();
	chars[0] = Char.ToLower(chars[0]);
	return new string(chars);
}
#>
